# coding: utf-8

"""
    GTEx Portal API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated
from gtex_openapi.models.app_models_request_parameters_hardy_scale import AppModelsRequestParametersHardyScale
from gtex_openapi.models.autolysis_score import AutolysisScore
from gtex_openapi.models.available_projects import AvailableProjects
from gtex_openapi.models.chromosome import Chromosome
from gtex_openapi.models.data_type import DataType
from gtex_openapi.models.donor_age_bracket import DonorAgeBracket
from gtex_openapi.models.donor_sex import DonorSex
from gtex_openapi.models.file import File
from gtex_openapi.models.ischemic_time_group import IschemicTimeGroup
from gtex_openapi.models.open_access_files_metadata import OpenAccessFilesMetadata
from gtex_openapi.models.paginated_response_annotation import PaginatedResponseAnnotation
from gtex_openapi.models.paginated_response_collapsed_gene_model_exon import PaginatedResponseCollapsedGeneModelExon
from gtex_openapi.models.paginated_response_dataset_sample import PaginatedResponseDatasetSample
from gtex_openapi.models.paginated_response_functional_annotation import PaginatedResponseFunctionalAnnotation
from gtex_openapi.models.paginated_response_list_union_str_float import PaginatedResponseListUnionStrFloat
from gtex_openapi.models.paginated_response_subject import PaginatedResponseSubject
from gtex_openapi.models.paginated_response_tissue_site_detail import PaginatedResponseTissueSiteDetail
from gtex_openapi.models.paginated_response_variant import PaginatedResponseVariant
from gtex_openapi.models.path_category import PathCategory
from gtex_openapi.models.tissue_site_detail_id import TissueSiteDetailId
from gtex_openapi.models.tissue_site_ontology_id import TissueSiteOntologyId

from gtex_openapi.api_client import ApiClient, RequestSerialized
from gtex_openapi.api_response import ApiResponse
from gtex_openapi.rest import RESTResponseType


class DatasetsEndpointsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_annotation_api_v2_dataset_annotation_get(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseAnnotation:
        """Get Annotation

        This service returns the list of annotations and allowed values by which a particular dataset can be subsetted. Results may be filtered by dataset.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_annotation_api_v2_dataset_annotation_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseAnnotation",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_annotation_api_v2_dataset_annotation_get_with_http_info(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseAnnotation]:
        """Get Annotation

        This service returns the list of annotations and allowed values by which a particular dataset can be subsetted. Results may be filtered by dataset.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_annotation_api_v2_dataset_annotation_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseAnnotation",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_annotation_api_v2_dataset_annotation_get_without_preload_content(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Annotation

        This service returns the list of annotations and allowed values by which a particular dataset can be subsetted. Results may be filtered by dataset.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_annotation_api_v2_dataset_annotation_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseAnnotation",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_annotation_api_v2_dataset_annotation_get_serialize(
        self,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/annotation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseCollapsedGeneModelExon:
        """Get Collapsed Gene Model Exon

        This service returns the collapsed exons in the gene model of the given gene. Gene-level and exon-level expression quantification were based on the GENCODE annotation, collapsed to a single transcript model for each gene using an algorithm developed by the GTEx analysis team.  By default, this service queries the models used by the latest GTEx release.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_with_http_info(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseCollapsedGeneModelExon]:
        """Get Collapsed Gene Model Exon

        This service returns the collapsed exons in the gene model of the given gene. Gene-level and exon-level expression quantification were based on the GENCODE annotation, collapsed to a single transcript model for each gene using an algorithm developed by the GTEx analysis team.  By default, this service queries the models used by the latest GTEx release.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_without_preload_content(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Collapsed Gene Model Exon

        This service returns the collapsed exons in the gene model of the given gene. Gene-level and exon-level expression quantification were based on the GENCODE annotation, collapsed to a single transcript model for each gene using an algorithm developed by the GTEx analysis team.  By default, this service queries the models used by the latest GTEx release.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_collapsed_gene_model_exon_api_v2_dataset_collapsed_gene_model_exon_get_serialize(
        self,
        gencode_id,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if gencode_id is not None:
            
            _query_params.append(('gencodeId', gencode_id))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/collapsedGeneModelExon',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get(
        self,
        project_id: AvailableProjects,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OpenAccessFilesMetadata:
        """Get Downloads Page Data

        Retrieves all the files belonging to the given `project_id` for display on the `Downloads Page`

        :param project_id: (required)
        :type project_id: AvailableProjects
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OpenAccessFilesMetadata",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_with_http_info(
        self,
        project_id: AvailableProjects,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OpenAccessFilesMetadata]:
        """Get Downloads Page Data

        Retrieves all the files belonging to the given `project_id` for display on the `Downloads Page`

        :param project_id: (required)
        :type project_id: AvailableProjects
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OpenAccessFilesMetadata",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_without_preload_content(
        self,
        project_id: AvailableProjects,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Downloads Page Data

        Retrieves all the files belonging to the given `project_id` for display on the `Downloads Page`

        :param project_id: (required)
        :type project_id: AvailableProjects
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OpenAccessFilesMetadata",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_downloads_page_data_api_v2_dataset_open_access_files_metadata_get_serialize(
        self,
        project_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_id is not None:
            
            _query_params.append(('project_id', project_id.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/openAccessFilesMetadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_file_list_api_v2_dataset_file_list_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[File]:
        """Get File List

        Get all the files in GTEx dataset for Download page

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_list_api_v2_dataset_file_list_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[File]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_file_list_api_v2_dataset_file_list_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[File]]:
        """Get File List

        Get all the files in GTEx dataset for Download page

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_list_api_v2_dataset_file_list_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[File]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_file_list_api_v2_dataset_file_list_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get File List

        Get all the files in GTEx dataset for Download page

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_list_api_v2_dataset_file_list_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[File]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_file_list_api_v2_dataset_file_list_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/fileList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseCollapsedGeneModelExon:
        """Get Full Get Collapsed Gene Model Exon

        This service allows the user to query the full Collapsed Gene Model Exon of a specific gene by gencode ID

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_with_http_info(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseCollapsedGeneModelExon]:
        """Get Full Get Collapsed Gene Model Exon

        This service allows the user to query the full Collapsed Gene Model Exon of a specific gene by gencode ID

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_without_preload_content(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Full Get Collapsed Gene Model Exon

        This service allows the user to query the full Collapsed Gene Model Exon of a specific gene by gencode ID

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseCollapsedGeneModelExon",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_full_get_collapsed_gene_model_exon_api_v2_dataset_full_collapsed_gene_model_exon_get_serialize(
        self,
        gencode_id,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if gencode_id is not None:
            
            _query_params.append(('gencodeId', gencode_id))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/fullCollapsedGeneModelExon',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_functional_annotation_api_v2_dataset_functional_annotation_get(
        self,
        chromosome: Chromosome,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseFunctionalAnnotation:
        """Get Functional Annotation

        This endpoint retrieves the functional annotation of a certain chromosome location. Default to most recent dataset release.

        :param chromosome: (required)
        :type chromosome: Chromosome
        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_functional_annotation_api_v2_dataset_functional_annotation_get_serialize(
            chromosome=chromosome,
            start=start,
            end=end,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseFunctionalAnnotation",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_functional_annotation_api_v2_dataset_functional_annotation_get_with_http_info(
        self,
        chromosome: Chromosome,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseFunctionalAnnotation]:
        """Get Functional Annotation

        This endpoint retrieves the functional annotation of a certain chromosome location. Default to most recent dataset release.

        :param chromosome: (required)
        :type chromosome: Chromosome
        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_functional_annotation_api_v2_dataset_functional_annotation_get_serialize(
            chromosome=chromosome,
            start=start,
            end=end,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseFunctionalAnnotation",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_functional_annotation_api_v2_dataset_functional_annotation_get_without_preload_content(
        self,
        chromosome: Chromosome,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Functional Annotation

        This endpoint retrieves the functional annotation of a certain chromosome location. Default to most recent dataset release.

        :param chromosome: (required)
        :type chromosome: Chromosome
        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_functional_annotation_api_v2_dataset_functional_annotation_get_serialize(
            chromosome=chromosome,
            start=start,
            end=end,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseFunctionalAnnotation",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_functional_annotation_api_v2_dataset_functional_annotation_get_serialize(
        self,
        chromosome,
        start,
        end,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if chromosome is not None:
            
            _query_params.append(('chromosome', chromosome.value))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if end is not None:
            
            _query_params.append(('end', end))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/functionalAnnotation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get(
        self,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseListUnionStrFloat:
        """Get Linkage Disequilibrium By Variant Data

        Find linkage disequilibrium (LD) data for a given variant

        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_serialize(
            variant_id=variant_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_with_http_info(
        self,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseListUnionStrFloat]:
        """Get Linkage Disequilibrium By Variant Data

        Find linkage disequilibrium (LD) data for a given variant

        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_serialize(
            variant_id=variant_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_without_preload_content(
        self,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Linkage Disequilibrium By Variant Data

        Find linkage disequilibrium (LD) data for a given variant

        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_serialize(
            variant_id=variant_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_linkage_disequilibrium_by_variant_data_api_v2_dataset_ld_by_variant_get_serialize(
        self,
        variant_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if variant_id is not None:
            
            _query_params.append(('variantId', variant_id))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/ldByVariant',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_linkage_disequilibrium_data_api_v2_dataset_ld_get(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseListUnionStrFloat:
        """Get Linkage Disequilibrium Data

        Find linkage disequilibrium (LD) data for a given gene.  This endpoint returns linkage disequilibrium data for the cis-eQTLs found associated with the provided gene in a specified dataset. Results are queried by gencode ID. By default, the service queries the latest GTEx release. Specify a dataset ID to fetch results from a different dataset.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_data_api_v2_dataset_ld_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_linkage_disequilibrium_data_api_v2_dataset_ld_get_with_http_info(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseListUnionStrFloat]:
        """Get Linkage Disequilibrium Data

        Find linkage disequilibrium (LD) data for a given gene.  This endpoint returns linkage disequilibrium data for the cis-eQTLs found associated with the provided gene in a specified dataset. Results are queried by gencode ID. By default, the service queries the latest GTEx release. Specify a dataset ID to fetch results from a different dataset.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_data_api_v2_dataset_ld_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_linkage_disequilibrium_data_api_v2_dataset_ld_get_without_preload_content(
        self,
        gencode_id: Annotated[StrictStr, Field(description="A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9")],
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Linkage Disequilibrium Data

        Find linkage disequilibrium (LD) data for a given gene.  This endpoint returns linkage disequilibrium data for the cis-eQTLs found associated with the provided gene in a specified dataset. Results are queried by gencode ID. By default, the service queries the latest GTEx release. Specify a dataset ID to fetch results from a different dataset.

        :param gencode_id: A Versioned GENCODE ID of a gene, e.g. ENSG00000065613.9 (required)
        :type gencode_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_linkage_disequilibrium_data_api_v2_dataset_ld_get_serialize(
            gencode_id=gencode_id,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseListUnionStrFloat",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_linkage_disequilibrium_data_api_v2_dataset_ld_get_serialize(
        self,
        gencode_id,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if gencode_id is not None:
            
            _query_params.append(('gencodeId', gencode_id))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/ld',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sample_api_v2_dataset_sample_get(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx sample ID")] = None,
        tissue_sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A list of Tissue Sample ID(s)")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        sex: Optional[DonorSex] = None,
        path_category: Annotated[Optional[List[PathCategory]], Field(description="A list of Pathology Category(s)")] = None,
        tissue_site_detail_id: Annotated[Optional[List[TissueSiteDetailId]], Field(description="Tissues of interest")] = None,
        aliquot_id: Optional[List[Annotated[str, Field(strict=True)]]] = None,
        autolysis_score: Optional[List[AutolysisScore]] = None,
        hardy_scale: Annotated[Optional[List[AppModelsRequestParametersHardyScale]], Field(description="A list of Hardy Scale(s) of interest")] = None,
        ischemic_time: Annotated[Optional[List[Annotated[int, Field(le=2100, strict=True, ge=-1300)]]], Field(description="Ischemic Time for the sample of interest")] = None,
        ischemic_time_group: Optional[List[IschemicTimeGroup]] = None,
        rin: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        uberon_id: Annotated[Optional[List[TissueSiteOntologyId]], Field(description="A list of Uberon ID(s) of interest.")] = None,
        data_type: Optional[List[DataType]] = None,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseDatasetSample:
        """Get Sample

        This service returns information of samples used in analyses from all datasets. Results may be filtered by dataset ID, sample ID, subject ID, sample metadata, or other provided parameters. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sample_id: GTEx sample ID
        :type sample_id: List[str]
        :param tissue_sample_id: A list of Tissue Sample ID(s)
        :type tissue_sample_id: List[str]
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param sex:
        :type sex: DonorSex
        :param path_category: A list of Pathology Category(s)
        :type path_category: List[PathCategory]
        :param tissue_site_detail_id: Tissues of interest
        :type tissue_site_detail_id: List[TissueSiteDetailId]
        :param aliquot_id:
        :type aliquot_id: List[str]
        :param autolysis_score:
        :type autolysis_score: List[AutolysisScore]
        :param hardy_scale: A list of Hardy Scale(s) of interest
        :type hardy_scale: List[AppModelsRequestParametersHardyScale]
        :param ischemic_time: Ischemic Time for the sample of interest
        :type ischemic_time: List[int]
        :param ischemic_time_group:
        :type ischemic_time_group: List[IschemicTimeGroup]
        :param rin:
        :type rin: List[float]
        :param uberon_id: A list of Uberon ID(s) of interest.
        :type uberon_id: List[TissueSiteOntologyId]
        :param data_type:
        :type data_type: List[DataType]
        :param sort_by:
        :type sort_by: SampleSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sample_api_v2_dataset_sample_get_serialize(
            dataset_id=dataset_id,
            sample_id=sample_id,
            tissue_sample_id=tissue_sample_id,
            subject_id=subject_id,
            age_bracket=age_bracket,
            sex=sex,
            path_category=path_category,
            tissue_site_detail_id=tissue_site_detail_id,
            aliquot_id=aliquot_id,
            autolysis_score=autolysis_score,
            hardy_scale=hardy_scale,
            ischemic_time=ischemic_time,
            ischemic_time_group=ischemic_time_group,
            rin=rin,
            uberon_id=uberon_id,
            data_type=data_type,
            sort_by=sort_by,
            sort_direction=sort_direction,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseDatasetSample",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sample_api_v2_dataset_sample_get_with_http_info(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx sample ID")] = None,
        tissue_sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A list of Tissue Sample ID(s)")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        sex: Optional[DonorSex] = None,
        path_category: Annotated[Optional[List[PathCategory]], Field(description="A list of Pathology Category(s)")] = None,
        tissue_site_detail_id: Annotated[Optional[List[TissueSiteDetailId]], Field(description="Tissues of interest")] = None,
        aliquot_id: Optional[List[Annotated[str, Field(strict=True)]]] = None,
        autolysis_score: Optional[List[AutolysisScore]] = None,
        hardy_scale: Annotated[Optional[List[AppModelsRequestParametersHardyScale]], Field(description="A list of Hardy Scale(s) of interest")] = None,
        ischemic_time: Annotated[Optional[List[Annotated[int, Field(le=2100, strict=True, ge=-1300)]]], Field(description="Ischemic Time for the sample of interest")] = None,
        ischemic_time_group: Optional[List[IschemicTimeGroup]] = None,
        rin: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        uberon_id: Annotated[Optional[List[TissueSiteOntologyId]], Field(description="A list of Uberon ID(s) of interest.")] = None,
        data_type: Optional[List[DataType]] = None,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseDatasetSample]:
        """Get Sample

        This service returns information of samples used in analyses from all datasets. Results may be filtered by dataset ID, sample ID, subject ID, sample metadata, or other provided parameters. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sample_id: GTEx sample ID
        :type sample_id: List[str]
        :param tissue_sample_id: A list of Tissue Sample ID(s)
        :type tissue_sample_id: List[str]
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param sex:
        :type sex: DonorSex
        :param path_category: A list of Pathology Category(s)
        :type path_category: List[PathCategory]
        :param tissue_site_detail_id: Tissues of interest
        :type tissue_site_detail_id: List[TissueSiteDetailId]
        :param aliquot_id:
        :type aliquot_id: List[str]
        :param autolysis_score:
        :type autolysis_score: List[AutolysisScore]
        :param hardy_scale: A list of Hardy Scale(s) of interest
        :type hardy_scale: List[AppModelsRequestParametersHardyScale]
        :param ischemic_time: Ischemic Time for the sample of interest
        :type ischemic_time: List[int]
        :param ischemic_time_group:
        :type ischemic_time_group: List[IschemicTimeGroup]
        :param rin:
        :type rin: List[float]
        :param uberon_id: A list of Uberon ID(s) of interest.
        :type uberon_id: List[TissueSiteOntologyId]
        :param data_type:
        :type data_type: List[DataType]
        :param sort_by:
        :type sort_by: SampleSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sample_api_v2_dataset_sample_get_serialize(
            dataset_id=dataset_id,
            sample_id=sample_id,
            tissue_sample_id=tissue_sample_id,
            subject_id=subject_id,
            age_bracket=age_bracket,
            sex=sex,
            path_category=path_category,
            tissue_site_detail_id=tissue_site_detail_id,
            aliquot_id=aliquot_id,
            autolysis_score=autolysis_score,
            hardy_scale=hardy_scale,
            ischemic_time=ischemic_time,
            ischemic_time_group=ischemic_time_group,
            rin=rin,
            uberon_id=uberon_id,
            data_type=data_type,
            sort_by=sort_by,
            sort_direction=sort_direction,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseDatasetSample",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sample_api_v2_dataset_sample_get_without_preload_content(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx sample ID")] = None,
        tissue_sample_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A list of Tissue Sample ID(s)")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        sex: Optional[DonorSex] = None,
        path_category: Annotated[Optional[List[PathCategory]], Field(description="A list of Pathology Category(s)")] = None,
        tissue_site_detail_id: Annotated[Optional[List[TissueSiteDetailId]], Field(description="Tissues of interest")] = None,
        aliquot_id: Optional[List[Annotated[str, Field(strict=True)]]] = None,
        autolysis_score: Optional[List[AutolysisScore]] = None,
        hardy_scale: Annotated[Optional[List[AppModelsRequestParametersHardyScale]], Field(description="A list of Hardy Scale(s) of interest")] = None,
        ischemic_time: Annotated[Optional[List[Annotated[int, Field(le=2100, strict=True, ge=-1300)]]], Field(description="Ischemic Time for the sample of interest")] = None,
        ischemic_time_group: Optional[List[IschemicTimeGroup]] = None,
        rin: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        uberon_id: Annotated[Optional[List[TissueSiteOntologyId]], Field(description="A list of Uberon ID(s) of interest.")] = None,
        data_type: Optional[List[DataType]] = None,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Sample

        This service returns information of samples used in analyses from all datasets. Results may be filtered by dataset ID, sample ID, subject ID, sample metadata, or other provided parameters. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sample_id: GTEx sample ID
        :type sample_id: List[str]
        :param tissue_sample_id: A list of Tissue Sample ID(s)
        :type tissue_sample_id: List[str]
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param sex:
        :type sex: DonorSex
        :param path_category: A list of Pathology Category(s)
        :type path_category: List[PathCategory]
        :param tissue_site_detail_id: Tissues of interest
        :type tissue_site_detail_id: List[TissueSiteDetailId]
        :param aliquot_id:
        :type aliquot_id: List[str]
        :param autolysis_score:
        :type autolysis_score: List[AutolysisScore]
        :param hardy_scale: A list of Hardy Scale(s) of interest
        :type hardy_scale: List[AppModelsRequestParametersHardyScale]
        :param ischemic_time: Ischemic Time for the sample of interest
        :type ischemic_time: List[int]
        :param ischemic_time_group:
        :type ischemic_time_group: List[IschemicTimeGroup]
        :param rin:
        :type rin: List[float]
        :param uberon_id: A list of Uberon ID(s) of interest.
        :type uberon_id: List[TissueSiteOntologyId]
        :param data_type:
        :type data_type: List[DataType]
        :param sort_by:
        :type sort_by: SampleSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sample_api_v2_dataset_sample_get_serialize(
            dataset_id=dataset_id,
            sample_id=sample_id,
            tissue_sample_id=tissue_sample_id,
            subject_id=subject_id,
            age_bracket=age_bracket,
            sex=sex,
            path_category=path_category,
            tissue_site_detail_id=tissue_site_detail_id,
            aliquot_id=aliquot_id,
            autolysis_score=autolysis_score,
            hardy_scale=hardy_scale,
            ischemic_time=ischemic_time,
            ischemic_time_group=ischemic_time_group,
            rin=rin,
            uberon_id=uberon_id,
            data_type=data_type,
            sort_by=sort_by,
            sort_direction=sort_direction,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseDatasetSample",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sample_api_v2_dataset_sample_get_serialize(
        self,
        dataset_id,
        sample_id,
        tissue_sample_id,
        subject_id,
        age_bracket,
        sex,
        path_category,
        tissue_site_detail_id,
        aliquot_id,
        autolysis_score,
        hardy_scale,
        ischemic_time,
        ischemic_time_group,
        rin,
        uberon_id,
        data_type,
        sort_by,
        sort_direction,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sampleId': 'multi',
            'tissueSampleId': 'multi',
            'subjectId': 'multi',
            'ageBracket': 'multi',
            'pathCategory': 'multi',
            'tissueSiteDetailId': 'multi',
            'aliquotId': 'multi',
            'autolysisScore': 'multi',
            'hardyScale': 'multi',
            'ischemicTime': 'multi',
            'ischemicTimeGroup': 'multi',
            'rin': 'multi',
            'uberonId': 'multi',
            'dataType': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if tissue_sample_id is not None:
            
            _query_params.append(('tissueSampleId', tissue_sample_id))
            
        if subject_id is not None:
            
            _query_params.append(('subjectId', subject_id))
            
        if age_bracket is not None:
            
            _query_params.append(('ageBracket', age_bracket))
            
        if sex is not None:
            
            _query_params.append(('sex', sex.value))
            
        if path_category is not None:
            
            _query_params.append(('pathCategory', path_category))
            
        if tissue_site_detail_id is not None:
            
            _query_params.append(('tissueSiteDetailId', tissue_site_detail_id))
            
        if aliquot_id is not None:
            
            _query_params.append(('aliquotId', aliquot_id))
            
        if autolysis_score is not None:
            
            _query_params.append(('autolysisScore', autolysis_score))
            
        if hardy_scale is not None:
            
            _query_params.append(('hardyScale', hardy_scale))
            
        if ischemic_time is not None:
            
            _query_params.append(('ischemicTime', ischemic_time))
            
        if ischemic_time_group is not None:
            
            _query_params.append(('ischemicTimeGroup', ischemic_time_group))
            
        if rin is not None:
            
            _query_params.append(('rin', rin))
            
        if uberon_id is not None:
            
            _query_params.append(('uberonId', uberon_id))
            
        if data_type is not None:
            
            _query_params.append(('dataType', data_type))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by.value))
            
        if sort_direction is not None:
            
            _query_params.append(('sortDirection', sort_direction.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/sample',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_subject_api_v2_dataset_subject_get(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sex: Optional[DonorSex] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        hardy_scale: Annotated[Optional[Any], Field(description="The hardy scale of interest")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseSubject:
        """Get Subject

        This service returns information of subjects used in analyses from all datasets. Results may be filtered by dataset ID, subject ID, sex, age bracket or Hardy Scale. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sex:
        :type sex: DonorSex
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param hardy_scale: The hardy scale of interest
        :type hardy_scale: AppModelsRequestParametersHardyScale
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subject_api_v2_dataset_subject_get_serialize(
            dataset_id=dataset_id,
            sex=sex,
            age_bracket=age_bracket,
            hardy_scale=hardy_scale,
            subject_id=subject_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseSubject",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_subject_api_v2_dataset_subject_get_with_http_info(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sex: Optional[DonorSex] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        hardy_scale: Annotated[Optional[Any], Field(description="The hardy scale of interest")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseSubject]:
        """Get Subject

        This service returns information of subjects used in analyses from all datasets. Results may be filtered by dataset ID, subject ID, sex, age bracket or Hardy Scale. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sex:
        :type sex: DonorSex
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param hardy_scale: The hardy scale of interest
        :type hardy_scale: AppModelsRequestParametersHardyScale
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subject_api_v2_dataset_subject_get_serialize(
            dataset_id=dataset_id,
            sex=sex,
            age_bracket=age_bracket,
            hardy_scale=hardy_scale,
            subject_id=subject_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseSubject",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_subject_api_v2_dataset_subject_get_without_preload_content(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        sex: Optional[DonorSex] = None,
        age_bracket: Annotated[Optional[List[DonorAgeBracket]], Field(description="The age bracket(s) of the donors of interest")] = None,
        hardy_scale: Annotated[Optional[Any], Field(description="The hardy scale of interest")] = None,
        subject_id: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="GTEx subject ID")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Subject

        This service returns information of subjects used in analyses from all datasets. Results may be filtered by dataset ID, subject ID, sex, age bracket or Hardy Scale. By default, this service queries the latest GTEx release.

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param sex:
        :type sex: DonorSex
        :param age_bracket: The age bracket(s) of the donors of interest
        :type age_bracket: List[DonorAgeBracket]
        :param hardy_scale: The hardy scale of interest
        :type hardy_scale: AppModelsRequestParametersHardyScale
        :param subject_id: GTEx subject ID
        :type subject_id: List[str]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subject_api_v2_dataset_subject_get_serialize(
            dataset_id=dataset_id,
            sex=sex,
            age_bracket=age_bracket,
            hardy_scale=hardy_scale,
            subject_id=subject_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseSubject",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_subject_api_v2_dataset_subject_get_serialize(
        self,
        dataset_id,
        sex,
        age_bracket,
        hardy_scale,
        subject_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ageBracket': 'multi',
            'subjectId': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if sex is not None:
            
            _query_params.append(('sex', sex.value))
            
        if age_bracket is not None:
            
            _query_params.append(('ageBracket', age_bracket))
            
        if hardy_scale is not None:
            
            _query_params.append(('hardyScale', hardy_scale.value))
            
        if subject_id is not None:
            
            _query_params.append(('subjectId', subject_id))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/subject',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseTissueSiteDetail:
        """Get Tissue Site Detail

        Retrieve all tissue site detail information in the database

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseTissueSiteDetail",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_with_http_info(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseTissueSiteDetail]:
        """Get Tissue Site Detail

        Retrieve all tissue site detail information in the database

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseTissueSiteDetail",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_without_preload_content(
        self,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tissue Site Detail

        Retrieve all tissue site detail information in the database

        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_serialize(
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseTissueSiteDetail",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tissue_site_detail_api_v2_dataset_tissue_site_detail_get_serialize(
        self,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/tissueSiteDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_variant_api_v2_dataset_variant_get(
        self,
        snp_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A Snp ID")] = None,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        chromosome: Optional[Chromosome] = None,
        pos: Optional[List[Annotated[int, Field(le=248945542, strict=True, ge=0)]]] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseVariant:
        """Get Variant

        This service returns information about a variant, including position, dbSNP RS ID, the reference allele, the alternative allele, and whether the minor allele frequency is >= 1%. For GTEx v6p, there is also information about whether the whole exome sequence and chip sequencing data are available. Results may be queried by GTEx variant ID (variantId), dbSNP RS ID (snpId) or genomic location (chromosome and pos). Variants are identified based on the genotype data of each dataset cohort, namely, are dataset-dependent. Each variant is assigned a unique GTEx variant ID (i.e. the primary key). Not all variants have a mappable dbSNP RS ID. By default, this service queries the latest GTEx release.

        :param snp_id: A Snp ID
        :type snp_id: str
        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param chromosome:
        :type chromosome: Chromosome
        :param pos:
        :type pos: List[int]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_api_v2_dataset_variant_get_serialize(
            snp_id=snp_id,
            variant_id=variant_id,
            dataset_id=dataset_id,
            chromosome=chromosome,
            pos=pos,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_variant_api_v2_dataset_variant_get_with_http_info(
        self,
        snp_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A Snp ID")] = None,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        chromosome: Optional[Chromosome] = None,
        pos: Optional[List[Annotated[int, Field(le=248945542, strict=True, ge=0)]]] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseVariant]:
        """Get Variant

        This service returns information about a variant, including position, dbSNP RS ID, the reference allele, the alternative allele, and whether the minor allele frequency is >= 1%. For GTEx v6p, there is also information about whether the whole exome sequence and chip sequencing data are available. Results may be queried by GTEx variant ID (variantId), dbSNP RS ID (snpId) or genomic location (chromosome and pos). Variants are identified based on the genotype data of each dataset cohort, namely, are dataset-dependent. Each variant is assigned a unique GTEx variant ID (i.e. the primary key). Not all variants have a mappable dbSNP RS ID. By default, this service queries the latest GTEx release.

        :param snp_id: A Snp ID
        :type snp_id: str
        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param chromosome:
        :type chromosome: Chromosome
        :param pos:
        :type pos: List[int]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_api_v2_dataset_variant_get_serialize(
            snp_id=snp_id,
            variant_id=variant_id,
            dataset_id=dataset_id,
            chromosome=chromosome,
            pos=pos,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_variant_api_v2_dataset_variant_get_without_preload_content(
        self,
        snp_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A Snp ID")] = None,
        variant_id: Annotated[Optional[StrictStr], Field(description="A gtex variant ID")] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        chromosome: Optional[Chromosome] = None,
        pos: Optional[List[Annotated[int, Field(le=248945542, strict=True, ge=0)]]] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Variant

        This service returns information about a variant, including position, dbSNP RS ID, the reference allele, the alternative allele, and whether the minor allele frequency is >= 1%. For GTEx v6p, there is also information about whether the whole exome sequence and chip sequencing data are available. Results may be queried by GTEx variant ID (variantId), dbSNP RS ID (snpId) or genomic location (chromosome and pos). Variants are identified based on the genotype data of each dataset cohort, namely, are dataset-dependent. Each variant is assigned a unique GTEx variant ID (i.e. the primary key). Not all variants have a mappable dbSNP RS ID. By default, this service queries the latest GTEx release.

        :param snp_id: A Snp ID
        :type snp_id: str
        :param variant_id: A gtex variant ID
        :type variant_id: str
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param chromosome:
        :type chromosome: Chromosome
        :param pos:
        :type pos: List[int]
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_api_v2_dataset_variant_get_serialize(
            snp_id=snp_id,
            variant_id=variant_id,
            dataset_id=dataset_id,
            chromosome=chromosome,
            pos=pos,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_variant_api_v2_dataset_variant_get_serialize(
        self,
        snp_id,
        variant_id,
        dataset_id,
        chromosome,
        pos,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'pos': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if snp_id is not None:
            
            _query_params.append(('snpId', snp_id))
            
        if variant_id is not None:
            
            _query_params.append(('variantId', variant_id))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if chromosome is not None:
            
            _query_params.append(('chromosome', chromosome.value))
            
        if pos is not None:
            
            _query_params.append(('pos', pos))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/variant',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_variant_by_location_api_v2_dataset_variant_by_location_get(
        self,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        chromosome: Chromosome,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResponseVariant:
        """Get Variant By Location

        This service allows the user to query information about variants on a certain chromosome at a certain location

        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param chromosome: (required)
        :type chromosome: Chromosome
        :param sort_by:
        :type sort_by: VariantSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_by_location_api_v2_dataset_variant_by_location_get_serialize(
            start=start,
            end=end,
            chromosome=chromosome,
            sort_by=sort_by,
            sort_direction=sort_direction,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_variant_by_location_api_v2_dataset_variant_by_location_get_with_http_info(
        self,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        chromosome: Chromosome,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResponseVariant]:
        """Get Variant By Location

        This service allows the user to query information about variants on a certain chromosome at a certain location

        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param chromosome: (required)
        :type chromosome: Chromosome
        :param sort_by:
        :type sort_by: VariantSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_by_location_api_v2_dataset_variant_by_location_get_serialize(
            start=start,
            end=end,
            chromosome=chromosome,
            sort_by=sort_by,
            sort_direction=sort_direction,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_variant_by_location_api_v2_dataset_variant_by_location_get_without_preload_content(
        self,
        start: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        end: Annotated[int, Field(le=250000000, strict=True, ge=0)],
        chromosome: Chromosome,
        sort_by: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        dataset_id: Annotated[Optional[Any], Field(description="Unique identifier of a dataset. Usually includes a data source and data release.")] = None,
        page: Annotated[Optional[Annotated[int, Field(le=1000000, strict=True, ge=0)]], Field(description="The 0-based numeric ID of the page to retrieve")] = None,
        items_per_page: Optional[Annotated[int, Field(le=100000, strict=True, ge=1)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Variant By Location

        This service allows the user to query information about variants on a certain chromosome at a certain location

        :param start: (required)
        :type start: int
        :param end: (required)
        :type end: int
        :param chromosome: (required)
        :type chromosome: Chromosome
        :param sort_by:
        :type sort_by: VariantSortBy
        :param sort_direction:
        :type sort_direction: SortDirection
        :param dataset_id: Unique identifier of a dataset. Usually includes a data source and data release.
        :type dataset_id: DatasetId
        :param page: The 0-based numeric ID of the page to retrieve
        :type page: int
        :param items_per_page:
        :type items_per_page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_variant_by_location_api_v2_dataset_variant_by_location_get_serialize(
            start=start,
            end=end,
            chromosome=chromosome,
            sort_by=sort_by,
            sort_direction=sort_direction,
            dataset_id=dataset_id,
            page=page,
            items_per_page=items_per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResponseVariant",
            '400': "Message",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_variant_by_location_api_v2_dataset_variant_by_location_get_serialize(
        self,
        start,
        end,
        chromosome,
        sort_by,
        sort_direction,
        dataset_id,
        page,
        items_per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if end is not None:
            
            _query_params.append(('end', end))
            
        if chromosome is not None:
            
            _query_params.append(('chromosome', chromosome.value))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by.value))
            
        if sort_direction is not None:
            
            _query_params.append(('sortDirection', sort_direction.value))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id.value))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if items_per_page is not None:
            
            _query_params.append(('itemsPerPage', items_per_page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/dataset/variantByLocation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


